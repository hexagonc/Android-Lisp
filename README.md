# Android Lisp GUI Builder
## Introduction
This repository contains sample projects that demonstrate the versatility of a Lisp interpreter that I created for Java. This repository also contains some technical design UML diagrams that I will be updating (probably slowly) over time.  The main projects and installation instructions are described below.  Over time, I will also update the repository Wiki with technical information on the Lisp interpreter and a usage guide for the sample projects.
## Sample Projects Included
###	AndroidLispGUIBuilder 
This Android application project is the central showcase for the Lisp interpreter.  Adding more features, polish and sample programs to this project will be my main focus right now.  Eventually, I'd like this to be a self-contained Android application for teaching programming.  Currently, it has a code editor which also functions as a Lisp REPL.  From the code editor, one can save and load Lisp source files to device storage or to Dropbox if you have a developer app key.  Because editing code is difficult with most Android soft keyboards, I added the ability to create and insert code templates into the editor.  The code editor is also used to build Android View hiearchies that can be added to a Fragment or ViewGroup so that one can define a full graphical user interface using Lisp.  Most View attributes that can be defined in xml can also be defined in Lisp, with functions standing in for xml elements.  In the code editor, opne can create View hierarchies, set View attributes like backgrounds and text colors and even define event handlers all with Lisp.  Even if you just want to quickly mock up a user interface that will eventually be implemented in xml or constructed programmatically, the AndroidLispGUIBuilder can be used to put together a quick interactive wireframe of how a UI component will work.  

In line with my goal for AndroidLispGUIBuilder as a teaching tool, I also added some special Lisp functions that allow you to program a Lego Mindstorms  NXT using bluetooth.  This way, one can augment a lesson on creating event-based graphical user interfaces with event-based robotic control.  There is a pre-defined code template called _lego mindstorms sample_ which shows how to create a graphical user interface for selecting an NXT from a set of paired bluetooth devices, connecting to that NXT, and controlling a Lego rover robot.  This code template contains a number of useful examples of using Lisp to define the event handlers for an Android Widget. There are other pre-defined code templates that further demonstrate what can be done with the Android Lisp GUI Builder.  Again, Lisp support for built-in Android functionality is a work in progress so there may be some features missing.

### AndroidTools
This is an Android library project which contains the core api for the Android Lisp interpreter.  It can be used if you just want to build a View hierarchy using Lisp but don't care for the frontend provided by the AndroidLispGUIBuilder app.  In addition to the  main Lisp api, which is contained in the **com.evolved.automata.lisp** and **com.evolved.automata.android.lisp** packages, there are some utility classes which wrap standard Android functions and some custom Views that I have found useful.  Warning!  Other than the code specifically referenced by the "*.lisp" packages, most of the other classes are old, probably buggy and are subject to removal or changes with future versions of this repository so use them at your own risk!

### DesktopLispTester
This is a barebones sample project that implements a simple REPL for the Lisp interpreter in Java.  If you want to get a general sense for how the interpreter works and how it can be used, I would look at the admittedly sparse unit tests that are defined in this project.  The core Lisp interpreter, which is referenced by this project, is compatible with any Java SE 1.6 and above.  It is probably easy to back-port to Java 1.5 as well although I haven't tested this.  The Eclipse project itself is configured for Java 1.6.  There's not much to say about this project itself.  If you want want a version of Lisp on Java that is easy to extend with your own built-in functions, then this is the project to start with.  I was able to extend the language pretty easily to control an Aldebaran NAO robot and the Sony AIBO by adding custom Lisp functions that wrapped the vendor supplied SDKs.  Note that there are some significant differences between the version of Lisp here and Common Lisp.  Because much of my own personal use of the Lisp interpreter has been for robotics, I've added a lot of special functions that have no analog in Common Lisp.  Due to mistakes and forgetfulness, some of my functions are named differently than their Common Lisp equivalents.  Periodically, I will update the Wiki with technical information on the behavior of the Lisp interpreter as well as a function reference.  Ultimately, I want to be able to support a rich Lisp API on Java and for the desktop version of the Lisp interpreter, I want to eventually allow one to create simple Swing applications with Lisp.  

##Installing the Android Lisp GUI Builder App from Eclipse (Android Studio instructions to come later):
Clone the repository to a directory, **_X_**.  The Eclipse projects are stored in the directory **X/Android-Lisp/projects/eclipse**.  Start Eclipse with this as the workspace folder.  Then go to "File -> Import... -> General -> Existing projects into workspace".
Select **X/Android-Lisp/projects/eclipse** as the base folder and check all projects within.   The repository is organized so that the Eclipse projects can automatically find shared source folders; if you use a folder other than **X/Android-Lisp/projects/eclipse** for your workspace then you'll have to individually update the build paths to link the appropriate source folders.  These projects use Apache Ivy to install third party libraries from Maven Repository.  After installing (if necessary) the IvyDE Eclipse plugin from http://www.apache.org/dist/ant/ivyde/updatesite, right click the ivy.xml file in the package explorer for AndroidLispGUIBuilder and click "Add Ivy Library" from the bottom of the context menu.  If this opens a dialog screen for "IvyDE Managed Libraries", configure the Ivy libraries as follows:
* Go to the "Classpath" tab and check the "Enable project specific settings" checkbox. 
* Make sure that "retrieved artifacts" is checked under "Build the classpath with".  The retrieved pattern should be **libs/[artifact]-[revision].[ext]**.  This is because Android jar dependencies must be stored in the _libs_ folder under your project.  
* Below this, make sure that 'Types' is set to at least 'jar, bundle'.  
* Click "Finish".  
Configure the Ivy libraries for the AndroidTools project similarly.  You'll also have to manually create a _src_ folder (such as **X/Android-Lisp/projects/eclipse/AndroidTools/src**) on the filesystem for the AndroidTools project  since git cannot retrieve an empty folder from a repository.  (The _src_ folder is empty because the main code for AndroidTools is linked from an external source, in the directory 
**X/Android-Lisp/common/src/main**.)  Due to a limitation of Android, (or Eclipse, not sure which is responsible), you can only attach sources for an Android library project from one source folder so I chose to base the attached sources on the external linked sources rather than any sources defined in the AndroidTools project itself.

The Android GUI Builder code should run on any Android device with SDK 14 (Ice Cream Sandwich) or greater.  However, if you are building in Eclipse with a JDK of 1.7 or greater than you'll need to set the Android project build target in Eclipse to SDK 19 or greater.  

## Dropbox Configuration
If you want your users to be able to load source files into the code editor of AndroidLispGUIBuilder from their Dropbox accounts, you'll need to sign up for and get an app Key from Dropbox.  Your application will need at least "App Folder" level of permissions.  Once you have an app key, you need to store an encrypted version of the app key in the "string.xml" resource values for AndroidLispGUIBuilder.  This string resource is called _enc_dropbox_app_key_.  You'll also need to set the string resource value for _dropbox_app_client_name_ which represents your own unique name for the AndroidLispGUIBuilder application.  

The encryption that is used to protect the app key is not meant to be particularly robust security.  It is certainly useless if you are distributing code based on this repository but don't use Proguard or some other means of obfuscation.  What little security that is provided by this encryption is mostly due to the fact that the method itself is not expected to be used for this purpose (you might be amused upon learning what it is based off of!).  Basically, the app key is secured by a symmetric encryption algorithm, so that once you hardcode the shared secret in the file, _GuiBuilderConfiguration.java_, the same function that encrypts the plaintext app key can also decrypt the encrypted key.  If you aren't too bothered by the risk of someone decompiling your code and getting your app key, at a minimum, you should probably change the value of the field _GuiBuilderConfiguration.seed_ to some random value and mix up the letters that are used for the fields, _d1_, _d2_, _d3_ and _d4_.  Once you do that, you can get the encrypted value of your app key by first setting the resource string, _enc_dropbox_app_key_, to the unencrypted app key.  Then you run the app, AndroidLispGUIBuilder, in debug mode and inspect the return value from the method, _GuiBuilderConfiguration.encryptDecrypt()_.  This will provide you the encrypted app key.  Now, all that is left is to set the resource value _enc_dropbox_app_key_ to this.  Once the resource strings _enc_dropbox_app_key_ and _dropbox_app_client_name_ are defined, your users will be able to authenticate themselves to Dropbox and authorize your app to access their Dropbox files.  The option to load files from Dropbox will not be available on the code editor tab until you have set an app key.

##Program Behavior
AndroidLispGUIBuilder is organized as a simple tab activity.  The initial tab you'll see, labelled "Console", contains a code editor, REPL and code management controls for saving and loading code.  The most basic usage is to simply type in a Lisp expression in the code editor and press "Evaluate".  The result will appear in the bottom console window under "Console Output".  Multiple Lisp command expressions are executed sequentially although only the value of the last executed function will be printed to the "Console Output".  For example, if you type into the code editor:
```
(+ 12 454)
(* 12 (/ 78 23))
```
the result of pressing "Evaluate" will be the value of evaluating `(* 12 (/ 78 23))` (about 40.69).  The code editor represents the top level "environment", which is a space for variables and function definitions.  [Environments](Android-Lisp/common/src/main/com/evolved/automata/lisp/Environment.java) can be thought of like a "stack frame" or a "lexical scope" and can be nested to define functions and closures.  So if you execute multiple expressions, some of which have side-effects, like:
```
(setq x (+ 34 100))
(setq value (format "x is %1$s" (* x 10)))
```
then _x_ and _value_ now exist as global variables.  These variables will persist in the top level "environment" even if you press "Clear", which merely erases the code editor.  If you clear the code editor and enter only _x_, and then press "Evaluate", the result will be 134.  This value will persist so long as the AndroidLispGUIBuilder application is running.  View hierarchites can be created with AndroidLispGUIBuilder and structured similarly to how you would construct them with Android xml.  For example, having evaluated the commands above, you could clear the code editor and enter:
```
(vertical-layout :width "match_parent"
                 :height 200
                 :background-color "green"
                 (text value))
```
Upon pressing "Evaluate", the function _vertical-layout_ is evaluated which results in the function _text_ also being evaluated.  Functions like _vertical-layout_ and _text_ return a datastructure that acts as a proxy for an Android View.  Depending on the widget they represent, there are predefined Lisp keyword arguments that correspond to layout and View attributes.  So in this case, a vertical LinearLayout of height 200 dp (numeric values for length attributes are interpretted as in dp), width "match_parent" and background-color "green" contains a TextView widget.  The function _text_ returns an object which acts as a wrapper for a TextView and for this function, any string arguments are interpreted as the label for the TextView.  If you don't specify the width or height of a View, then the width and height both default to "wrap_content".  If the final value that is evaluated in the code editor returns a proxy for a View, then the proxy can be attached to AndroidLispGUIBuilder's view hierarchy and rendered in the "Render" tab.  This is done automatically by pressing the "Render" buttom.  If the last value evaluated in the code editor is not an object that wraps a View then pressing "Render" has not effect.

There are several pre-defined code templates which demonstrate more sophisticated user interfaces that can be built.  Code templates are generally meant to represent reusable snippets that are put together to form a larger body of code.  However, being samples that demonstrate the capability of the Lisp interpreter and runtime environment, the pre-defined code templates are meant to be executed as standalone programs in the code editor (make sure "replace editor contents" is checked before inserting these code templates).  Currently, there is:
* A program which demonstrates how to build the user interface for a simple tic-tac-toe game using lisp functions
* A program that not only builds the ui but which incorporates a very stupid artificial intelligence for playing tic-tac-toe and keeping track of scores
* A program which demonstrates simple text to speech and speech to text
* A program that allows the user to connect to a Lego Mindstorms NXT robot, configure it and control it with bluetooth
* Two more test code templates that can be evaluated after the others and are really just demonstrations of user interface

Most of these sample templates require little additional explanation except for the code template, "lego mindstorms sample" should be executed after you evaluate the code template, "robot control samples" since the latter is used to configure the Lego Mindstorms NXTs.  In the future, I'll be adding more sophisticated code template samples.

##Future
This repository represents an ongoing project that I will be constantly adding more features to.  I will add support in lisp for more Android widgets and more layout parameters for the existing widgets (especially the relative-layout).  I'll also eventually add user selectable AI for the tic-tac-toe agent to demonstrate different problem solving techniques in AI.  For example, there might be a tic-tac-toe agent that initially doesn't know how to play the game but which learns via reinforcement learning, or there might be an AI player that always plays super defensively at the cost of winning.  Periodically check the wiki in case I start updating it with additional documentation.

As mentioned above, I will eventually port the projects to Android Studio, since I believe Android Studio is much better behaved in a lot of ways than Eclipse (being also the officially 
supported IDE for Android).  Also, I believe having the projects in the Gradle project structure is more portable than the Eclipse project structure.  

##License
All of this code is MIT licensed, which is described [here](license.txt).