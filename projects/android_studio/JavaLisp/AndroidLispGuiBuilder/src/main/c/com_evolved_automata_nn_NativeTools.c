/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include "neural_library.h"
/* Header for class com_evolved_automata_nn_NativeTools */


/*
 * Class:     com_evolved_automata_nn_NativeTools
 * Method:    setDebugStatus
 * Signature: (Z)V
 */
JNIEXPORT void JNICALL Java_com_evolved_automata_nn_NativeTools_setDebugStatus(JNIEnv *env, jclass classObj, jboolean enabled)
{
  setDebugStatus(enabled);
}


/*
 * Class:     com_evolved_automata_nn_NativeTools
 * Method:    setSeed
 * Signature: (J)V
 */
JNIEXPORT void JNICALL Java_com_evolved_automata_nn_NativeTools_setSeed(JNIEnv *env, jclass classObj, jlong seed)
{
  setSeed((long)seed);
}

/*
 * Class:     com_evolved_automata_nn_NativeTools
 * Method:    setRNDAlgorithm
 * Signature: (I)V
 */
JNIEXPORT void JNICALL Java_com_evolved_automata_nn_NativeTools_setRNDAlgorithm (JNIEnv *env, jclass classObj, jint algorithm)
{
  switch (algorithm)
  {
    case 0:
      {
        setRNGMethod(JAVA_DERIVATIVE);
      }
      break;
    case 1:
    {
      setRNGMethod(PARK_AND_MILLER);
    }
      break;
    case 2:
    {
      setRNGMethod(MERSENNE_TWISTER);
    }
    break;
    case 3:
    {
      setRNGMethod(PLATFORM_DEFAULT);
    }
    break;
    default:
      printf("WARNING: Undefined RNG algorithm %d\n", algorithm);
  }
}

/*
 * Class:     com_evolved_automata_nn_NativeTools
 * Method:    randomLCG
 * Signature: ()D
 */
JNIEXPORT jdouble JNICALL Java_com_evolved_automata_nn_NativeTools_randomLCG(JNIEnv *env, jclass classObj)
{
  return randomLCG();
}

/*
 * Class:     com_evolved_automata_nn_NativeTools
 * Method:    initializeAllWeights
 * Signature: ([F)V
 */
JNIEXPORT void JNICALL Java_com_evolved_automata_nn_NativeTools_initializeAllWeights(JNIEnv *env, jclass classObj, jfloatArray jNetSpec)
{
  float* networkSpec;
  networkSpec = (*env)->GetFloatArrayElements(env, jNetSpec, NULL);
  initializeAllWeights(networkSpec);
  (*env)->ReleaseFloatArrayElements(env, jNetSpec, networkSpec, 0);
}

/*
 * Class:     com_evolved_automata_nn_NativeTools
 * Method:    resetNetworkToInitialState
 * Signature: ([F)V
 */
JNIEXPORT void JNICALL Java_com_evolved_automata_nn_NativeTools_resetNetworkToInitialState(JNIEnv *env, jclass classObj, jfloatArray jNetSpec)
{
  float* networkSpec;
  networkSpec = (*env)->GetFloatArrayElements(env, jNetSpec, NULL);
  resetNetworkToInitialState(networkSpec);
  (*env)->ReleaseFloatArrayElements(env, jNetSpec, networkSpec, 0);
}

/*
 * Class:     com_evolved_automata_nn_NativeTools
 * Method:    forwardPass
 * Signature: ([F[F)V
 */
JNIEXPORT void JNICALL Java_com_evolved_automata_nn_NativeTools_forwardPass(JNIEnv *env, jclass classObj, jfloatArray jNetSpec, jfloatArray jInputActivationArray)
{
  float* networkSpec = (*env)->GetFloatArrayElements(env, jNetSpec, NULL);
  float* inputActivation = (*env)->GetFloatArrayElements(env, jInputActivationArray, NULL);

  forwardPass(networkSpec, inputActivation);
  (*env)->ReleaseFloatArrayElements(env, jNetSpec, networkSpec, 0);
  (*env)->ReleaseFloatArrayElements(env, jInputActivationArray, inputActivation, 0);
}

/*
 * Class:     com_evolved_automata_nn_NativeTools
 * Method:    setInputActivation
 * Signature: ([F[F)V
 */
JNIEXPORT void JNICALL Java_com_evolved_automata_nn_NativeTools_setInputActivation(JNIEnv *env, jclass classObj, jfloatArray jNetSpec, jfloatArray jInputActivationArray)
{
  float* networkSpec = (*env)->GetFloatArrayElements(env, jNetSpec, NULL);
  float* inputActivation = (*env)->GetFloatArrayElements(env, jInputActivationArray, NULL);

  setInputActivation(networkSpec, inputActivation);
  (*env)->ReleaseFloatArrayElements(env, jNetSpec, networkSpec, 0);
  (*env)->ReleaseFloatArrayElements(env, jInputActivationArray, inputActivation, 0);
}

/*
 * Class:     com_evolved_automata_nn_NativeTools
 * Method:    updateForwardPassErrors
 * Signature: ([F[F)F
 */
JNIEXPORT jfloat JNICALL Java_com_evolved_automata_nn_NativeTools_updateForwardPassErrors(JNIEnv * env, jclass classObj, jfloatArray jNetSpec, jfloatArray jTargetOutputArray)
{
  float* networkSpec = (*env)->GetFloatArrayElements(env, jNetSpec, NULL);
  float* targetOutput = (*env)->GetFloatArrayElements(env, jTargetOutputArray, NULL);

  float error = updateForwardPassErrors(networkSpec, targetOutput);
  (*env)->ReleaseFloatArrayElements(env, jNetSpec, networkSpec, 0);
  (*env)->ReleaseFloatArrayElements(env, jTargetOutputArray, targetOutput, 0);
  return error;
}

/*
 * Class:     com_evolved_automata_nn_NativeTools
 * Method:    updateWeightsFromErrors
 * Signature: ([FI)V
 */
JNIEXPORT void JNICALL Java_com_evolved_automata_nn_NativeTools_updateWeightsFromErrors(JNIEnv *env, jclass classObj, jfloatArray jNetSpec, jint updateTypeInt)
{
  float* networkSpec = (*env)->GetFloatArrayElements(env, jNetSpec, NULL);
  
  updateWeightsFromErrors(networkSpec, updateTypeToInt(updateTypeInt));
  (*env)->ReleaseFloatArrayElements(env, jNetSpec, networkSpec, 0);

}

/*
 * Class:     com_evolved_automata_nn_NativeTools
 * Method:    getOutputActivation
 * Signature: ([F[F)V
 */
JNIEXPORT void JNICALL Java_com_evolved_automata_nn_NativeTools_getOutputActivation(JNIEnv *env, jclass classObj, jfloatArray netSpec, jfloatArray obuffer)
{ 
  float* networkSpec = (*env)->GetFloatArrayElements(env, netSpec, NULL);
  float* outputBuffer = (*env)->GetFloatArrayElements(env, obuffer, NULL);
  getOutputActivation(networkSpec, outputBuffer);

  (*env)->ReleaseFloatArrayElements(env, netSpec, networkSpec, 0);
  (*env)->ReleaseFloatArrayElements(env, obuffer, outputBuffer, 0);

}

/*
 * Class:     com_evolved_automata_nn_NativeTools
 * Method:    learnInputOutputPairMap
 * Signature: (I[F[FI[F)F
 */
JNIEXPORT jfloat JNICALL Java_com_evolved_automata_nn_NativeTools_learnInputOutputPairMap(JNIEnv *env, jclass classObj, jint numSamples, jfloatArray netSpec, jfloatArray tSpec, jint itemIndex, jfloatArray sBuffer)
{
  float* networkSpec = (*env)->GetFloatArrayElements(env, netSpec, NULL);
  float* trainingSpec = (*env)->GetFloatArrayElements(env, tSpec, NULL);
  float* specBuffer = (*env)->GetFloatArrayElements(env, sBuffer, NULL);

  TrainingSpecIndex index = getTrainingSpecIndex(networkSpec, numSamples);
  float result = learnInputOutputPairMap(index, networkSpec, trainingSpec, itemIndex, specBuffer);

  (*env)->ReleaseFloatArrayElements(env, netSpec, networkSpec, 0);
  (*env)->ReleaseFloatArrayElements(env, tSpec, trainingSpec, 0);
  (*env)->ReleaseFloatArrayElements(env, sBuffer, specBuffer, 0);
  return result;
}

/*
 * Class:     com_evolved_automata_nn_NativeTools
 * Method:    learnInputOutputPairMapWithDetails
 * Signature: (I[F[FI[F[F)V
 */
JNIEXPORT void JNICALL Java_com_evolved_automata_nn_NativeTools_learnInputOutputPairMapWithDetails(JNIEnv *env, jclass classObj, jint numSamples, jfloatArray netSpec, jfloatArray tSpec, jint itemIndex, jfloatArray sBuffer, jfloatArray rBuffer)
{
  float* networkSpec = (*env)->GetFloatArrayElements(env, netSpec, NULL);
  float* trainingSpec = (*env)->GetFloatArrayElements(env, tSpec, NULL);
  float* specBuffer = (*env)->GetFloatArrayElements(env, sBuffer, NULL);
  float* resultBuffer = (*env)->GetFloatArrayElements(env, rBuffer, NULL);
  
  TrainingSpecIndex index = getTrainingSpecIndex(networkSpec, numSamples);
  learnInputOutputPairMapWithDetails(index, networkSpec, trainingSpec, itemIndex, specBuffer, resultBuffer);

  (*env)->ReleaseFloatArrayElements(env, netSpec, networkSpec, 0);
  (*env)->ReleaseFloatArrayElements(env, tSpec, trainingSpec, 0);
  (*env)->ReleaseFloatArrayElements(env, sBuffer, specBuffer, 0);
  (*env)->ReleaseFloatArrayElements(env, rBuffer, resultBuffer, 0);

}

/*
 * Class:     com_evolved_automata_nn_NativeTools
 * Method:    learnTrainingSpec
 * Signature: (I[F[FIFZI)I
 */
JNIEXPORT jint JNICALL Java_com_evolved_automata_nn_NativeTools_learnTrainingSpec(JNIEnv *env, jclass classObj, jint numSamples, jfloatArray netSpec, jfloatArray tSpec, jint maxSteps, jfloat convergenceThreshold, jboolean allowWeightResetsP, jint uType)
{
  float* networkSpec = (*env)->GetFloatArrayElements(env, netSpec, NULL);
  float* trainingSpec = (*env)->GetFloatArrayElements(env, tSpec, NULL);

  // 
  TrainingSpecIndex index = getTrainingSpecIndex(networkSpec, numSamples);
  int steps = learnTrainingSpec(index, networkSpec, trainingSpec, maxSteps, convergenceThreshold, allowWeightResetsP, updateTypeToInt(uType));
  (*env)->ReleaseFloatArrayElements(env, netSpec, networkSpec, 0);
  (*env)->ReleaseFloatArrayElements(env, tSpec, trainingSpec, 0);
  return steps;
}

/*
 * Class:     com_evolved_automata_nn_NativeTools
 * Method:    createCappedLSTM
 * Signature: ([F[F[F)I
 */
JNIEXPORT jint JNICALL Java_com_evolved_automata_nn_NativeTools_createCappedLSTM(JNIEnv *env, jclass classObj, jfloatArray netSpec, jfloatArray staInput, jfloatArray stoInput)
{
  float* networkSpec = (*env)->GetFloatArrayElements(env, netSpec, NULL);
  float* startInput = (*env)->GetFloatArrayElements(env, staInput, NULL);
  float* stopInput = (*env)->GetFloatArrayElements(env, stoInput, NULL);

  int steps = createCappedLSTM(networkSpec, startInput, stopInput);

  (*env)->ReleaseFloatArrayElements(env, netSpec, networkSpec, 0);
  (*env)->ReleaseFloatArrayElements(env, staInput, startInput, 0);
  (*env)->ReleaseFloatArrayElements(env, stoInput, stopInput, 0);

  return steps;
}

/*
 * Class:     com_evolved_automata_nn_NativeTools
 * Method:    appendVectorToSequence
 * Signature: ([F[F[F[FIFZI)I
 */
JNIEXPORT jint JNICALL Java_com_evolved_automata_nn_NativeTools_appendVectorToSequence(JNIEnv *env, jclass classObj, jfloatArray cNetwork, jfloatArray staInput, jfloatArray stoInput, jfloatArray nInput, jint maxSteps, jfloat convergenceThreshold, jboolean allowWeightResetsP, jint updateType)
{
  float* cappedNetworkSpec = (*env)->GetFloatArrayElements(env, cNetwork, NULL);
  float* startInput = (*env)->GetFloatArrayElements(env, staInput, NULL);
  float* stopInput = (*env)->GetFloatArrayElements(env, stoInput, NULL);
  float* newInput = (*env)->GetFloatArrayElements(env, nInput, NULL);

  int steps = appendVectorToSequence(cappedNetworkSpec, startInput, stopInput, newInput, maxSteps, convergenceThreshold, allowWeightResetsP, updateTypeToInt(updateType));

  (*env)->ReleaseFloatArrayElements(env, cNetwork, cappedNetworkSpec, 0);
  (*env)->ReleaseFloatArrayElements(env, staInput, startInput, 0);
  (*env)->ReleaseFloatArrayElements(env, stoInput, stopInput, 0);
  (*env)->ReleaseFloatArrayElements(env, nInput, newInput, 0);

  return steps;
}

/*
 * Class:     com_evolved_automata_nn_NativeTools
 * Method:    resetCappedLSTM
 * Signature: ([F[FZ)V
 */
JNIEXPORT void JNICALL Java_com_evolved_automata_nn_NativeTools_resetCappedLSTM(JNIEnv *env, jclass classObj, jfloatArray nSpec, jfloatArray iState, jboolean onlyMetaDataP)
{
  float* networkSpec = (*env)->GetFloatArrayElements(env, nSpec, NULL);
  float* initialState = (*env)->GetFloatArrayElements(env, iState, NULL);

  resetCappedLSTM(networkSpec, initialState, onlyMetaDataP);

  (*env)->ReleaseFloatArrayElements(env, nSpec, networkSpec, 0);
  (*env)->ReleaseFloatArrayElements(env, iState, initialState, 0);

}


